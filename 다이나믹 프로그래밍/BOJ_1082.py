"""
문제
스타트링크가 입주한 사무실은 방 번호를 직접 정할 수 있다.

방 번호를 정하려면 1층 문방구에서 파는 숫자를 구매해야 한다. 숫자를 구매하기 위해 준비한 금액은 M원이고, M원을 모두 사용해야 한다.

문방구에서 파는 숫자는 0부터 N-1까지이고, 각 숫자 i의 가격은 Pi이다. 문방구에서는 같은 숫자를 여러 개 구매할 수 있고,

문방구는 매우 많은 재고를 보유하고 있기 때문에, 항상 원하는 만큼 숫자를 구매할 수 있다. 방 번호가 0이 아니라면 0으로 시작할 수 없다.

예를 들어, N = 3, M = 21, P0 = 6, P1 = 7, P2 = 8이라면, 만들 수 있는 가장 큰 방 번호는 210이다.

M원을 모두 사용해서 만들 수 있는 가장 큰 방 번호를 구해보자


"""

"""
관찰 및 해결전략 

어떻게 방번호 숫자를 구해하면 최소의 가격으로 최대 방번호를 만들 수 있을까
경우의수를 전수조사하는 완전탐색을 생각해 볼 수 있다 

10개의 방번호를 구매하는 방법은 0번방 50개 0번방 / 0번방 50개 1번방 1개 ...
방번호 하나를 여러개 살 수 있고 1의 가격으로 50을 채워야한다면 50번을 채울 수 있다 그런데 이 방법은 방번호를 만들어서 최댓값으로 만들 수 없다
0번방을 50개 만든다면 만들 수 있는 방번호는 00000000...000 로 되고 
9번방을 50개 만든다면 만들 수 있는 방번호는 99999999...999 로 된다 
그러면 경우의 수는 많아진다 그래서 경우의 술을 줄이면서도 최댓값을 갱신해나가면서 저장해놓는다면 좋다
여기서 n제한이 10이고 가격의 제한이 50이므로 충분히 작다 완전탁색으로 가능할것같지만 경우의수가 많아진다 

그래서 여가서는 다이나믹 프로그래밍 알고리즘을 사용하여 메모리를 효율적으로 쓰면서도 빠르게 구할 수 있도록 한다 

다이나믹 프로그래밍을 구현하기 위해서는 파라미터의 값과 구하고자하는 목표값의 테이블 정의이다 

여기서 파라미터는 각 물건의 값이고 어떤 번호를 구매했을 경우 현재 가지게되는 최대번호 라고 정의한다 

그리고 최대의 방번호가 되기 위해서는 인덱스 뒤에서 부터 정의하면 최대방번호를 구할 수 있다 
테이블은  
dp[현재돈] = 현재돈으로 만들 수 있는 최댓값
가 되고
점화식은 
dp[i] = max([dp[i],idx,dp[i-m]*10 + idx]) 가 된다
여기서 m은 idx번째 번호를 구매한 가격이고 
i 는 모든 가격을 차례대로 넣어보면서 만들 수 있는 최대방번호를 구하기 위한 값들이다 
그래서 i는 m보다 큰값을 가지면서 i-m의 가격으로 살 수 있었던 번호를 10의 자리로 보내고 idx번호가 그 다음으로 오도록 하여 최댓값을 갱신해나가는 방식이다  

하나씩 예를 들어보자 

문제의 예제에 6, 7, 8의 물건이 순차대로 있고 21까지 제한이 있다고 가정하자 
그럼 먼저 8을 산다 번호는 2이다 
그렇게 되면 dp[8] = max(dp[8],2,dp[0]*10 + 2) 가 된다 여기서 계속 i가 증가하여 9가되든 10이 되든 계속 최댓값은 2가 저장이 될것이다 
기존의 8미만의 가격으로는 이 물건을 살 수 없으므로 그대로 0으로 둔다 
9 , 10 , 11 ...이렇게 현재 살 수 있는 돈이 바뀐다고 하더라도 2 하나뿐이다 
16이 되는 순간 바뀐다 16으로는 2를 두개 살 수 있다 
dp[16] = max(dp[16],2,dp[8]*10 + 2) 가 된다 기존의 가격 dp[8]에는 2가 이미 저장되어있고 십의 자리로 밀리면서 기존의 번호를 구매하면 22가 된다 
그 이후로도 계속 21까지는 dp[21]까지 22로 구매할 수 있음을 알 수 있다 

만약 뒤에서부터 최댓값 갱신을 하는 것이 아니라 앞에서부터 하게 된다면 십을 곱해주는 연산은 다음에 붙일 방번호에 곱해주어야 한다 

그리고 그 다음에 1번째 번호를 산다고 가정하면
dp[7] = max(dp[7] , 1, dp[0] * 10 + 1) 이 된다  1이 저장된다 
dp[14] = max(dp[14] , 1, dp[7]*10 + 1) 이 되며 11이 저장된다 
헌데 dp[15] = max(dp[15], 1 , dp[8]*10 + 1) 에서 dp[8]은 2가되고 저장되는 값은 21이 된다 
앞서 dp[15]에는 기존의 8의 가격으로 구매한 2가 저장되어있었지만(15로 살 수 있는 번호는 2뿐이었으므로 )
dp[21] = max(dp[21], 1, dp[14]*10+1) 이 된다 
기존의 dp[21]에는 8을 두개산 22가 들어 있다 하지만 지금 현재 dp[14]에는 11이 들어 있고 111이 최댓값이되므로 갱신된다 
마지막으로 세번째 방번호인 0을 구매했을 경우 dp[21] = max(dp[21] , 0, dp[15]*10 + 0 ) 에서 기존의 dp[21]에 111과 현재 dp[15]에 들어있는
21에 0을 더한 210과 비교하여 최댓갑시 최좆적으로 210이 되면서 마무리가 된다 
이렇게 계속 최댓값이 갱신되면서 기존의 값을 활용하여 업데이트 치는 dp알고리즘으로 수월하게 풀 수 있다 

여기서 9, 10 ,11 등 1개만 살 수 있고 2개이상을 못사는 현재가격으로 1개만 구입하는 즉 번호 하나만을 저장하는 것으로 기록해 두는것이 핵심이다 

앞에서부터 최댓값을 갱신해나간다고 하면  0은 더해도 0이므로 0번 번호를 구매했을 경우는 문자열로 처리하는것이 좋다

그래서 이문제의 방향은 뒤에서부터 하나씩 더해가며 최댓값을 갱신하는것이고 앞에서부터 한다면 문자열로 처리해볼 수 있다 

여기서 더 핵심적인것은 파라미터 설정이다 우선 파라미터 설정을 현재돈이 아닌 방번호와 현재가격으로 두었다 

현재 살 수 있는 돈을 늘려가며 현재 번호를 구매하고 남은 돈으로 구매했던 기록의 번호들을 불러오는 방식이다

그래서 타겟이 방번호이고 파라미터가 현재가격이다 라는 사실을 명확히 해야 된다 이러한 유형의 문제가 자주 등장하므로 어떤 부분이 파라미터이고 타겟인지 설정을 분명히하고
점화식을 세우자
  
"""

n = int(input())
prices = list(map(int, input().split()))
m = int(input())
dp = [0] * (m+1)
for i in range(n-1,-1,-1):
    cur = prices[i] # 일단 지금 현재방번호를 구매한후 ( 마지막부터 구매시도 )
    # 현재 cur의 가격으로 살 수 있는 방번호의 최댓값
    # 9의 돈으로 살 수 있는건 8하나뿐이므로 2가 저장되고 10의돈으로도 11의 돈으로도 살 수 있는 방번호는 2하나뿐이다
    # 16이 되었을 경우 22로 살 수 있으므로 이 값을 저장한다
    for j in range(cur,m+1):
        dp[j] = max(dp[j],dp[j-cur]*10 + i)

print(max(dp))





